\label{cap:proposal}
\chapter{Um sistema de recomendação semântico baseado em conteúdo}

Desde de tempos o homem busca construir ferramentas e máquinas que facilitem, ampliem, sustem sua capacidade de trabalho e produção. Com o advento dos computadores e dos programas de máquina, o \textit{software} tornou-se essencial para a contínua demanda de problemas e desafios da crescente população global. Como avaliado por \cite{Sommerville2010},  o software não se restringe a propriedades materiais das leis da física ou por processos de manufatura. Por um lado, este fato simplifica a engenharia de software devido falta de restrições físicas, mas o torna complexo e de alto custo na realização de mudanças. Dessa forma, com a crescente quantidade de computadores e a diversidade de dispositivos, é cada vez mais relevante a qualidade de software.

O tema não é novo e já é levantado desde a década de sessenta, como na conferência NATO \citep{NR68} sobre problemas e desafios no desenvolvimento de software. A qualidade de software não somente aborda problemas do ponto de vista da coordenação do desenvolvimento, viabilizando a execução pelas máquinas, mas também estuda a importância da legibilidade a fim facilitar a manutenção e compreensão por humanos. Assim, é de suma importância documentar funcionalidades, decisões técnicas a serem utilizadas no processo do desenvolvimento de software, para que outros possam entender o trabalho que está sendo construído \citep{Pressman2009}.

Neste capítulo será apresentado os requisitos funcionais e não funcionais para um sistema de de recomendação semântico baseado em conteúdo. Serão discutida as tecnologias, comportamentos, modelos e arquiteturas utilizadas. Por fim, será apresentado um protótipo do sistema, utilizado para recomendações de filmes.

\section{Requisitos}

Os requisitos de um sistema são descrições do que deve fazer, suas funcionalidades e serviços que restringem sua operação \citep{Sommerville2010}. Tais requisitos são uma reflexão das necessidades dos consumidores do sistema e definem um propósito específico, como cadastrar um usuário, encontrar produtos etc. Os requisitos de software, então, tratam-se de descobrir, analisar e documentar tais serviços e restrições para a operação do produto final. A descrição desses requisitos deve ser clara e objetiva, para apenas descrever o objetivo final da funcionalidade a ser desenvolvida.

Os requisitos de software são tradicionalmente classificados entre \textbf{funcionais} e \textbf{não funcionais}, para diferentes níveis de detalhamento e diferentes leitores.

\begin{itemize}
	\item{\textbf{Requisitos funcionais}: Descrevem o funcionamento do sistema, e para isso devem prover como o sistema deve reagir à entrada/saída assim como seus comportamentos em diferentes situações.}
	
	\item{\textbf{Requisitos não funcionais}: Devem estabelecer as restrições das funcionalidades e serviços oferecidos pelo sistema. São descritas caraterísticas gerais do sistema, como a usabilidade que não se referem a termos específicos como os requisitos funcionais. Comumente também são descritas questões que devem ser atendidas para a segurança e confiabilidade do sistema.}
\end{itemize}

Para cada requisito é utilizado um código para identificar a funcionalidade, assim facilitando referenciá-la durante o desenvolvimento. Nesta seção serão apresentados os requisitos funcionais e não funcionais para o desenvolvimento deste projeto. Para a descrição das funcionalidades optou-se por usar códigos com a sintaxe [RF0X] para requisitos funcionais e [RNF0X] para requisitos não funcionais. Junto ao código e a descrição do requisito foi adicionada a sua prioridade. As prioridades são classificadas em três categorias: a) \textbf{Essencial} para os que precisam ser implementados indispensavelmente, ou seja, são estritamente necessários para o funcionamento do sistema; b) \textbf{Importante} para os que são importantes para o funcionamento, mas não são cruciais; c) \textbf{Desejável} para os que não interferem diretamente nas funcionalidades básicas do sistema , embora relevantes, mas que podem ser deixados para ser implementados posteriormente.

\subsection{Requisitos funcionais}

A Tabela \ref{tab:req-funcionais} apresenta os requisitos funcionais do sistema.

\begin{table}[H]
	\label{tab:req-funcionais}
	\centering
	\caption{Requisitos funcionais do sistema.}
	\def\arraystretch{1.2} % padding da linhas da tabela
	\begin{tabular}{|m{1.2cm} | m{3cm} | m{7.2cm}| c | m{1.9cm}}
		\hline
		
		\multicolumn{1}{|c|}{\bfseries Código} & \multicolumn{1}{c|}{\bfseries Nome} & \multicolumn{1}{c|}{\bfseries Descrição} & \multicolumn{1}{c|}{\bfseries Prioridade} \\ \hline
		RF01	& Cadastrar usuário	& Realizar o cadastro de usuários para criação do seu perfil	& Essencial \\ \hline
		RF02	& Cadastrar usuário com o Facebook	& Permitir o cadastro de usuários utilizando sua conta do Facebook	& Importante \\ \hline
		RF03	& Fazer login/logout	& Usuários devem ser identificados permitindo a entrada e saída da aplicação	& Essencial \\ \hline
		RF04	& Fazer login pelo Facebook	& Permitir o login do usuário pelo Facebook	& Importante \\ \hline
		RF05	& Cadastrar filmes do usuário	& Usuários identificados podem cadastrar novos filmes no seu perfil	& Essencial \\ \hline
		RF06	& Visualizar filmes do usuário	& Usuários identificados podem visualizar os filmes cadastrados no seu perfil	& Essencial \\ \hline
		RF07	& Remover filmes do usuário	& Usuários identificados podem remover filmes cadastrados no seu perfil	& Essencial \\ \hline
		RF08	& Pesquisar filmes cadastrados	& Usuários identificados podem pesquisar filmes cadastrados na base do sistema	& Importante \\ \hline
		RF09	& Cadastrar filmes	& O sistema deve permitir a alimentação de filmes para a base dados	& Essencial \\ \hline
		RF010	& Edição de filmes	& O sistema deve permitir a edição de filmes alimentados para a base	& Essencial \\ \hline
		RF011	& Visualização de filmes recomendados	& O sistema deve ser capaz de criar uma lista de filmes recomendados, baseado nos filmes registrados do perfil do usuário	& Essencial \\ \hline
		RF012	& Coletar filmes do Facebook	& Usuários identificados devem poder importar filmes marcados no Facebook	& Importante \\ \hline
		RF013	& Visualizar informações do filme	& Usuários identificados devem ser capaz de visualização a informação de um filme específico, seja na lista de recomendações ou registrados no seu perfil	& Importante \\ \hline
	\end{tabular}
\end{table}

\subsection{Requisitos não funcionais}

A tabela \ref{tab:req-nao-funcionais} apresenta os requisitos não funcionais informando sua característica. Todos os requisitos apresentados são considerados essenciais.

\begin{table}[H]
	\label{tab:req-nao-funcionais}
	\centering
	\caption{Requisitos não funcionais do sistema.}
	\def\arraystretch{1.3} % padding da linhas da tabela
	\begin{tabular}{| m{1.3cm} | m{9.4cm}| c | m{2cm}}
		\hline
		\multicolumn{1}{|c|}{\bfseries Código} & \multicolumn{1}{c|}{\bfseries Descrição} & \multicolumn{1}{c|}{\bfseries Característica} \\ \hline
		RNF01	& O sistema deve ser fácil uso e dispensar prévio treinamento	& Usuabilidade \\ \hline
		RNF02	& O sistema deve ser simples de ser utilizado provendo informações e feedback de forma clara e objetiva	& Usuabilidade \\ \hline
		RNF03	& O sistema deve estar organizado de tal forma a não deixar o usuário confuso e ao mesmo tempo incentivar a sua exploração com interesse visual	& Usuabilidade \\ \hline
		RNF04	& O sistema deve ser capaz de atualizar as similaridades calculadas dos filmes em \textit{background}	& Funcionalidade \\ \hline
		RNF05	& O sistema deve prover uma metalinguagem para momentos em que o usuário deve aguardar o processamento de dados, tais como ícones, informativos etc.	& Usuabilidade \\ \hline
		RNF06	& O sistema deve possuir um desempenho adequado para que o cálculo da lista de filmes recomendados tenham o menor impacto de carregamento na navegação do usuário.	& Funcionalidade \\ \hline
		RNF07	& O sistema deve ser capaz de incluir novos filmes em \textit{background}	& Funcionalidade \\ \hline	
	\end{tabular}
\end{table}

\section{Arquitetura}

A arquitetura de software trata-se das estruturas e componentes, assim como as interações entre essas partes que irão compor o software do sistema. Para \cite{Perry1992} a arquitetura de software manifesta-se principalmente em partes do software do produto em relação a: 1) Requisitos para a determinação da informação, processamento e características que serão necessárias para o usuário e o sistema; 2) Arquitetura quando preocupa-se com a seleção de elementos, suas interações, e restrições necessárias para prover um \textit{framework} que satisfaça os requisitos; 3) Design quando está interessado na modularização e detalhamento do design dos elementos, algoritmos, procedimentos e tipos de dados que suportem a arquitetura e os requisitos; 4) Implementação quando preocupa-se com a representação de algoritmos, tipos de dados que satisfaçam a arquitetura, design e os requisitos.

Para a organização e estrutura deste projeto foi escolhida o padrão de arquitetura \ac{MVC}. O objetivo desse padrão é organizar o sistema em camadas em que cada uma seja responsável por funcionalidades específicas no fluxo entre o sistema e o usuário. Assim, o desenvolvimento e alterações podem ser realizadas de forma independente. No \ac{MVC} o sistema é estruturado em três camada que interagem entre si:

\begin{itemize}
	\item{\textbf{Model}: Camada da representação ou modelo para a manipulação dos dados da aplicação, sendo usado tanto na manipulação de elementos da interface como na persistência de dados.}
	
	\item{\textbf{View}: Camada da apresentação para o usuário, a interface. Envolve toda a parte de visualização de dados e interação com o sistema do ponto de vista do usuário.}
	
	\item{\textbf{Controller}: Camada que controla o fluxo das informações, validação, controle de acesso e comportamentos entre a \textit{view} e a \textit{model}.}
\end{itemize}

\section{Tecnologias}

Para o desenvolvimento do sistema foram escolhidas algumas tecnologias para arquitetura software, como linguagens de programação, \textit{framework} \ac{MVC}, processamento e banco dados, entre outras. A seguir serão apresentadas as tecnologias utilizadas.

\subsection{JAVA}

JAVA\footnote{https://www.java.com} é uma linguagem de programação de propósito genérico, desenvolvida originalmente por James Gosling na Sun Microsystems\footnote{ https://www.oracle.com/br/sun/index.html} em 1995. Atualmente a linguagem foi comprada pela Oracle Corporation\footnote{https://www.oracle.com}. As características em destaque da linguagem estão no fato de ser baseada em classes e orientada a objetos. A \ac{OOP} é um paradigma de programação que abstrai conceitos em objetos, que podem conter dados, campos e comportamentos nomeados de \textit{methods} \citep{Lewis2000}. 

Outra caraterística importante da linguagem trata-se da filosofia apresentada pelos desenvolvedores de “escreva uma vez, rode em qualquer lugar”. A filosofia trata-se da linguagem ser compilada por uma \ac{VM} possibilitando escrever um mesmo pedaço de código que possa ser portado para outra plataforma sem necessidade de alterá-lo, uma vez que cada \ac{VM} implementa as especificidades da nova plataforma abstraindo o acesso ao \ac{SO}.

A linguagem JAVA é usada em diversos sistemas e plataformas, com inúmeros propósitos, desde aplicações \textit{desktop}, pesquisa científica, desenvolvimento Web entre outros propósitos.

\subsection{Spring Boot}

Spring Boot\footnote{https://projects.spring.io/spring-boot/} é um projeto da 	Pivotal Software\footnote{https://pivotal.io} para facilitar o processo de configuração e publicação de aplicações e serviços providos pelo Spring\footnote{https://spring.io}, com baixo esforço e configuração. O \textit{Spring} é um framework \textit{open source}\footnote{Modelo de desenvolvimento que promove um licenciamento livre para o design ou esquematização  de um produto} que provê um compreensivo conjunto de modelos de configuração para aplicações JAVA. O elemento principal do \textit{Spring} é prover infraestrutura para aplicações oferecendo os seguintes principais recursos:

\begin{itemize}
	\item{\textbf{Inversão de Controle}: \ac{IOC}, também conhecido como \textit{dependency injection} é um princípio que as “dependências” devem ser supridas, injetadas por outro objeto. As dependências são objetos que serão usados como “serviços” para acessar suas funcionalidades, dentro dos \textit{containers} de \ac{IOC}. A injeção é a passagem da dependência para um objeto (o cliente) \citep{DependencyInjection2006}. O termo “inversão de controle” origina-se do fato que a criação de valores de classes externas ao objeto não deve ser realizada pelo próprio objeto mas, sim pelos \textit{containers} de \ac{IOC}.}
	
	\item{\textbf{Acesso a dados}: O framework possui diversas bibliotecas para o acesso a dados, tanto para bancos relacionais como não relacionais. Também é oferecido um sistema \ac{ORM} que trata-se de uma técnica para traduzir o formato de dados de um banco relacional para \ac{OOP}, facilitando sua manipulação.}
	
	\item{\textbf{Arquitetura MVC}: Fornece todo suporte para customizar e criar uma arquitetura \ac{MVC}.}
\end{itemize}

\subsection{HTML, CSS, Javascript}

O HTML\footnote{https://www.w3.org/html}, \ac{CSS}\footnote{https://www.w3.org/Style/CSS/} e JavaScript forma a principal pilha de tecnologias utilizadas na Web. O HTML é uma linguagem de marcação mantida pela \ac{W3C} para criação de páginas, originalmente desenvolvida por Tim-Berners-Lee \citep{Raggett1998}. O objetivo é a fácil construção e publicação de conteúdo no ambiente Web e consequentemente na \ac{WWW}. No \textit{Spring Boot} as páginas HTML podem ser escritas utilizando algum dos mecanismos de \textit{templates}, como o \textit{thymeleaf}. Uma das vantagens da utilização desses mecanismos é a herança de visualizações, assim como facilidade de interligar em manipular os dados passados pelo \textit{controller}.

O \ac{CSS} é uma linguagem para criar regras de estilização das páginas \ac{HTML}. O CSS cria ou altera um formato de apresentação (tamanho, cores, margens etc) de algum elemento do HTML, como blocos, parágrafos, imagens entre outros. Quanto ao JavaScript é uma linguagem de programação originalmente criada por Brendan Eich na Netscape Communications\footnote{ http://isp.netscape.com}. A linguagem é utilizada para controlar o comportamento de páginas HTML, oferecendo dinamicidade, podendo alterar elementos da página em tempo real.

\subsection{MySQL}

O MySQL\footnote{https://www.mysql.com} trata-se de um \ac{SGBD} que utiliza a linguagem \ac{SQL} para manipulação de dados guardados em um sistema de arquivos \citep{MySQLSGBD}. Originalmente desenvolvido por Michael Widenius em 1994, o seu foco é para o desenvolvimento de aplicações Web, embora tenha se popularizado para a maioria das plataformas existentes \citep{MySQLDevelopers}. Foi o banco de dados escolhido para a persistência de dados da aplicação, além de ser de fácil integração com o \textit{framework} \textit{Spring Boot}.

\subsection{Apache Jena}

Apache Jena\footnote{https://jena.apache.org} é um \textit{framework} \textit{open source} para Web Semântica, escrito na linguagem Java. A biblioteca provê uma \ac{API} que facilita a extração e criação de dados nos grafos  do \ac{RDF}, além de oferecer suporte para a linguagem de consulta \ac{SPARQL}. O objetivo da escolha dessa tecnologia para o projeto, é para facilitar a busca e navegação pelo grafo de entidades (\textit{resources}) no sistema da DBPedia\footnote{http://wiki.dbpedia.org} utilizando \ac{SPARQL}. Após o \ac{SR} extrair entidades das descrições do filme, essas serão buscadas no serviço da Web Semântica estendendo o conhecimento do recurso.

\subsection{Apache OpenNLP}

Apache OpenNLP\footnote{https://opennlp.apache.org} é um \textit{framework} \textit{open source} de aprendizado de máquina que é usado para processamento de \ac{NLP}. A biblioteca provê uma \ac{API} com serviços para geração de \textit{tokens}, sentenças, segmentação, reconhecimento de partes da fala, extração de entidade de nome, geração de \textit{chunks} (pedaços), entre outras tarefas do \ac{NLP}. A figura \ref{fig:nlp} mostra algumas das tarefas envolvidas no processamento de linguagem natural.

\begin{figure}
	\centering
	\includegraphics[scale=0.70]{imagens/nlp.jpg}
	\caption{Segmentação de tarefas no NLP. \citep{NLP2016}}
	\label{fig:nlp}
\end{figure}

No projeto essa tecnologia será utilizada para o \ac{NER} e extração de partes gramaticais presentes na descrição do filme, assim como a geração dos \textit{tokens}. O objetivo é que com essa biblioteca seja possível gerar \textit{tokens} com entidades encontradas, de nomes localizações, como também partes do texto de nomes próprios, substantivos e adjetivos.

\subsection{Apache Lucene}

Apache Lucene\footnote{https://lucene.apache.org} é um \textit{framework} \textit{open source} para sistemas de recuperação de informação e recomendação. O projeto oferece dois principais recursos: indexação e pesquisa de texto. Lucene é muito reconhecido por sua utilidade na implementação em mecanismos de buscas na Internet \citep{McCandless2010}. O projeto também é muito utilizado em sistemas de recomendação com implementação de diversos algoritmos para calcular a similaridade de documentos.
No projeto essa tecnologia será utilizada para tirar proveito dos algoritmos de similaridade, como o \textit{cossine similarity} (ver \ref{eq:cosine_sim}), possibilitando estender seu funcionamento e permitir integração com a biblioteca, facilitando o seu uso para outras pessoas e outros projetos.

\section{Funcionamento}

As tecnologias apresentadas anteriormente serão utilizadas para construir toda a arquitetura do sistema de recomendação. A proposta é criar uma recomendação baseada em conteúdo, e para este trabalho foi definido o domínio de filmes como exemplo de utilização. Sendo assim, o sistema possui algumas etapas de processamento para viabilizar a recomendação:

\begin{itemize}
	\item{\textbf{Coleta dos filmes}: Serão coletados dados dos filmes utilizando o projeto MovieLens\footnote{https://movielens.org} (ver \ref{ssec:dataModel}).}
	
	\item{\textbf{Pré-processamento dos filmes}: Nessa etapa após a coleta dos filmes, os dados serão previamente processados para a geração de \textit{tokens} com \ac{NLP}, analisando a descrição dos itens (sinopse dos filmes). Após todos os processamentos os \textit{tokens} serão persistidos no banco de dados.}
	
	\item{\textbf{Coleta das preferências do usuário}: Serão coletados dados das preferências dos usuários, ou seja, os filmes de interesse, que neste trabalho trata-se da coleção de filmes que o usuário gostou (\textit{like}). Nessa etapa poderá ser utilizado o perfil do Facebook para obter \footnote{https://facebook.com} para obter tais dados.}

	\item{\textbf{Cálculo da Similaridade}: Após a etapa de pré-processamento dos filmes, será realizado o cálculo da similaridade, utilizando o método proposto \ac{RLWS} entre uma representação que refletirá as preferências do usuário, com outros filmes que ele não tenha escolhido e/ou marcado como \textit{deslike}.}
	
	\item{\textbf{Geração das recomendações}: Como este trabalho trata-se da apresentação de um sistema de recomendação baseado em conteúdo, então as sugestões de novos itens depende exclusivamente do histórico do usuário. Sendo assim, com a similaridade comparada entre o perfil do usuário em relação a outros filmes, será gerada uma lista de tamanho qualquer com os melhores \textit{scores} obtidos do cálculo desta similaridade. Posteriormente essa coleção filmes sugeridos será armazenada no banco, podendo ser atualizada conforme o perfil do usuário altera ou novos filmes são cadastrados na base de dados. No item \ref{ssec:recsysAlgo} é demonstrado e discutido o algoritmo central para a similaridade e recomendação.}
	
	\item{\textbf{Apresentação dos resultados}: Apresentação dos resultados: Por fim o sistema apresentará os resultados das recomendações para o usuário.}		
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[scale=0.42]{imagens/recsys_fluxo.png}
	\caption{Fluxo das camadas do sistema de recomendação}
	\label{fig:recsys_fluxo}
\end{figure}

A figura \ref{fig:recsys_fluxo} mostra como esse fluxo de funcionalidades é operado por todo o sistema. A seguir será aprofundado mais algumas questões sobre a integração dessas camadas.

\subsection{Modelo de dados}

Para a estrutura do sistema de recomendação deste trabalho, foi elaborado um modelo de dados para persistir as preferências do usuário, informações dos filmes com seu pré-processamento pelo \ac{NLP}, além de uma estrutura de \textit{cache} para auxiliar o processamento do cálculo da similaridade. A figura \ref{fig:user_model} mostra como esses dados estão interligados. É importante ressaltar algumas observações quanto a esse modelo:

\begin{itemize}
	\item{A entidade "user\textunderscore movie" persiste as preferências do usuário, tanto dos filmes que ele marcou como \textit{like} e \textit{deslike}, sendo que o primeiro adquire valor de 1 e o outro de 0. Esse modelo pode ser futuramente revisado para aceitar valores que não sejam binários.}
	
	\item{A entidade "user\textunderscore recomendation" persiste as sugestões de filmes calculadas pelo sistema, e o atributo "similarity" trata-se do algoritmo de similaridade utilizado, o que torna-se especialmente útil para realizar comparações com outros métodos (será discutido no \ref{cap:evaluation})}.
	
	\item{A entidade "movie" persiste os dados dos filmes retirados do projeto MovieLens\footnote{https://movielens.org}, assim como o processamento da sinopse dos filmes para geração dos \textit{tokens}.}
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[scale=0.5]{imagens/user_model.png}
	\caption{Diagrama da modelagem dos dados}
	\label{fig:user_model}
\end{figure}
\label{ssec:dataModel}

\subsection{Preparação dos dados para recomendação}

Antes da execução das recomendações é necessário realizar a etapa do pré-processamento dos dados. Para cada filme é gerada uma sequência de tokens de palavras relevantes presentes na descrição. Essas palavras relevantes tratam-se do processo de exclusão daquelas que pouco agregam significado ao que se refere a temática do filme, como é o exemplo de preposições e conjunções. 

Para este projeto foi utilizado o \textit{framework} OpenNLP\footnote{https://opennlp.apache.org} para realizar a remoção das palavras não desejadas, que através da marcação das "partes do discurso", adiciona a cada palavra uma \textit{tag} com a parte da linguagem que ela representa, como adjetivos, nomes, verbos etc. Uma vez realizada a anotação do texto com as partes do discurso, foi definido apenas capturar as palavras marcadas com as seguintes tags, conforme mostra a tabela \ref{tab:nlp_tags}. Vale ressaltar que essas definições foram concebidas para língua inglesa.

\begin{table}[H]
	\label{tab:nlp_tags}
	\centering
	\caption{Relação das tags das partes do discurso}
	\def\arraystretch{1.3} % padding da linhas da tabela
	\begin{tabular}{| m{1.3cm} | m{9.4cm}| c | m{2cm}}
		\hline
		\multicolumn{1}{|c|}{\bfseries Tag} & \multicolumn{1}{c|}{\bfseries Descrição} \\ \hline
		NN & Substantivo, singular ou incontável \\ \hline 
		NNS	& Substantivo, plural \\ \hline
		JJ & Adjetivo \\ \hline
		JJR & Adjetivo comparativo \\ \hline
		JJS & Adjetivo superlativo \\ \hline
	\end{tabular}
\end{table}

Em sequência a lista das palavras retiradas da análise das partes do discurso, é incluída a lista de nomes retirados do processo de \ac{NER} (reconhecimento de entidades nomeadas), o que não é meramente o reconhecimento de nomes próprios da língua, mas também de nomes compostos. Esse processo é de grande valia para a etapa de similaridade uma vez que, tendo um nome como "Buzz Lightyear", apenas utilizando o processo da marcação das partes do discurso resultaria em dois termos "Buzz" e "Lightyear", sendo que o ideal seja ter o nome composto por inteiro. Para os nomes reconhecidos nesse processo foi realizada uma formatação para adequação a consultas \ac{SPARQL}, ou seja, nomes compostos como "Buzz Lightyear" serão formatados para "Buzz\textunderscore Lightyear".

A tabela \ref{tab:nlp_example} abaixo demonstra alguns exemplos do tratamento da descrição de filmes para geração de \textit{tokens}. 

\begin{table}[]
	\label{tab:nlp_example}
	\centering
	\caption{Exemplos da geração de tokens}
	\def\arraystretch{1.3} % padding da linhas da tabela
	\begin{tabular}{|p{2cm}|p{6cm}|p{6cm}|}
	\hline
	\textbf{Filme} & \textbf{Sinopse} & \textbf{Tokens} \\ \hline
	Toy Story & Led by Woody, Andy's toys live happily in his room until Andy's birthday brings Buzz Lightyear onto the scene. Afraid of losing his place in Andy's heart, Woody plots against Buzz. But when circumstances separate Buzz and Woody from their owner, the duo eventually learns to put aside their differences. & Andy, Andy, Buzz\_Lightyear, Andy, Buzz, Room, Birthday, Lightyear, Scene, Place, Heart, Owner, Duo \\ \hline
	GoldenEye & James Bond must unmask the mysterious head of the Janus Syndicate and prevent the leader from utilizing the GoldenEye weapons system to inflict devastating revenge on Britain. & James\_Bond, Britain, Mysterious, Head, Leader, System, Devastating, Revenge \\ \hline
	\end{tabular}
\end{table}

\section{Similaridade e recomendação}

A recomendação de itens envolve a predição de quão provável o usuário gostará do conteúdo recomendado que neste trabalho foi desenvolvido um método baseado em similaridade semântica. Conforme abordado no capítulo \ref{cap:semantic_web} a similaridade semântica utiliza-se e retira proveito das estruturas de uma ontologia que neste caso trata-se das acessíveis através do projeto do movimento \ac{LOD}, o DBPedia\footnote{http://wiki.dbpedia.org}. Diante disso, partindo de outros estudos que apresentaram métodos como LDSD \citep{PassantLDSD} e Resim \citep{PiaoResim}, este trabalho propõe um novo método, denominado de \ac{RLWS} para realizar a medida da distância entre dois recursos presentes no DBPedia, gerando um valor na escala de 0 a 1, onde valores menores denotam menos similaridade. 

\subsection{Fórmula para similaridade semântica}

A equação \ref{eq:rlws} demonstra o cálculo da similaridade semântica, que consiste em um conjunto de 5 funções  $C_d$, $C_i$, $C_{di}$, $C_{do}$, $C_{io}$. Estas funções tratam-se de levar em consideração a quantidade links de um recurso ou entre recursos dentro de um conjunto seguindo os princípios do \ac{LOD}, de acordo com a seguinte definição \citep{PiaoResim}:

\begin{definition}
Um conjunto que segue os princípios LOD é um grafo $G$ tal que $G = (R, L, I)$ aonde $R = \left\{r_1, r_2, ..., r_n\right\}$ é um conjunto de recursos identificados por suas URI, $L = \left\{i_1, i_2, ..., i_n\right\}$ é um conjunto de instâncias desses links entre recursos, como $i_i = <l_j, r_a, r_b>$.
\end{definition}

\begin{equation}
	RLWS(r_a, r_b) = 
	\begin{cases}
		1 \text{, } URI(r_a) = URI(r_b)\\
		1 - \frac{1}{1 + \frac{P_d(r_a, r_b) * w_d + P_i(r_a, r_b) * w_i}{w_d + w_i}} \text{, caso contrário}
	\end{cases}
\label{eq:rlws}
\end{equation}

\begin{equation}
	P_d(r_a, r_b) = \frac{\sum_i C_{di}(l_i, r_a, r_b) + \sum_i C_{do}(l_i, r_a, r_b)}{1 + \log (C_d(r_a) + C_d(r_b))}
\label{eq:rlws_ex1}
\end{equation}

\begin{equation}
	P_i(r_a, r_b) = \frac{\sum_i C_{ii}(li, r_a, r_b)}{1 + \log (C_i(r_a) + C_i(r_b))}
\label{eq:rlws_ex2}
\end{equation}

\begin{figure}
	\centering
	\includegraphics[scale=0.5]{imagens/cd_links.png}
	\caption{Imagem que retrata os links diretos saintes e entrantes de um recurso}
	\label{fig:cd_links}
\end{figure}

Para maior generalização o termo "link" será utilizado para se referir a ligações tanto como recursos ou propriedades relacionadas. Assim, as funções $C_d$ e $C_i$ tratam-se de computar os links distintos de um recurso qualquer, ou seja todas as ligações distintas a outros recursos, de forma direta e indireta respectivamente. No caso da função $C_d$, são computados todos os recursos distintos que sejam alcançados por uma propriedade qualquer através de um recurso analisado em questão, mais aqueles que partem de outro recurso e chegam nesse mesmo desejado. O exemplo da figura \ref{fig:cd_links} apresenta o recurso "Tom\_Cruise" a ser calculado, onde possui um link direto sainte para o recurso "American\_filma\_producers" através da propriedade "sujeito de", e outro link direto de entrada pelo recurso "Jack\_Reacher" através da propriedade "retratado por". 


\begin{lstlisting}[caption=Consulta SPARQL para contagem de links diretos, language=SQL, frame=single, label={cod:sparql_cd}, float, numbers=left]
SELECT (count (distinct ?r2) as ?x)
WHERE {
	{values (?r1) {(<http://dbpedia.org/resource/r1>)} ?r1 ?p1 ?r2 . FILTER (?r1 != ?r2) . FILTER (!isLiteral(?r2) )}
	UNION
	{values (?r1) {(<http://dbpedia.org/resource/r1>)} ?r2 ?p1 ?r1 . FILTER (?r1 != ?r2) . FILTER (!isLiteral(?r2) )}
}
\end{lstlisting}

A contagem desses links é realizada através da consulta \ac{SPARQL} conforme a figura \ref{fig:cd_links}. Quanto para função $C_i$ apenas são contabilizados os links indiretos de saída, por motivos de desempenho de consultas SPARQL no DBPedia. A imagem \ref{fig:ci_links} retrata o cenário para os links indiretos, e o código \ref{cod:sparql_ci} a contagem dos links indiretos.

\begin{figure}
	\centering
	\includegraphics[scale=0.5]{imagens/ci_links.png}
	\caption{Imagem que retrata os links indiretos saintes de um recurso}
	\label{fig:ci_links}
\end{figure}

\begin{lstlisting}[caption=Consulta SPARQL para contagem de links indiretos, language=SQL, frame=single, label={cod:sparql_ci}, float, numbers=left]
SELECT (count (distinct ?r3) as ?x)
WHERE {
	{values (?r1) {(<http://dbpedia.org/resource/r1>)} ?r2 ?p1 ?r1 . ?r2 ?p1 ?r3 . FILTER (?r1 != ?r3) . FILTER (!isLiteral(?r2) )}
}
\end{lstlisting}

Quanto as funções $Cdi$, $Cdo$ e $Cio$, referem-se a contagem dos links distintos compartilhados entre dois recursos, sendo os dois primeiros de forma direta e o último de forma indireta. As equações \ref{cod:sparql_cdio} e \ref{cod:sparql_cio} apresentam as consultas \ac{SPARQL} para realizar a contagem dos links.

\begin{lstlisting}[caption=Consulta SPARQL para contagem de links diretos (saíntes e entrantes) entre dois recursos, language=SQL, frame=single, label={cod:sparql_cdio}, float, numbers=left]
SELECT (count(distinct ?p1) as ?x)
WHERE {
	{values (?r1 ?r2) {(<http://dbpedia.org/resource/r1> <http://dbpedia.org/resource/r2>)} ?r1 ?p1 ?r2 . FILTER (?r1 != ?r2) . FILTER (!isLiteral(?r2)) } UNION
	{values (?r1 ?r2) {(<http://dbpedia.org/resource/r2> <http://dbpedia.org/resource/r1>)} ?r1 ?p1 ?r2 . FILTER (?r1 != ?r2) . FILTER (!isLiteral(?r2)) }
}
\end{lstlisting}

\begin{lstlisting}[caption=Consulta SPARQL para contagem de links indiretos (saíntes) entre dois recursos, language=SQL, frame=single, label={cod:sparql_cio}, float, numbers=left]
SELECT (count (distinct ?p1) as ?x)
WHERE {
	{values (?r1 ?r3) {(<http://dbpedia.org/resource/r1> <http://dbpedia.org/resource/r2>)} ?r2 ?p1 ?r1 . ?r2 ?p1 ?r3 . FILTER (?r1 != ?r3) . FILTER (!isLiteral(?r2) )}
}
\end{lstlisting}

A fórmula apresentada tenta obter um peso da porcentagem de participação da comparação entre dois recursos em relação ao universo da união dos links desses recursos. Para a participação dos links diretos $P_d$ é atribuída o peso $w_d$ e já para a participação $P_i$ o peso $w_i$. Assim, para a fórmula manter correta é necessário que a soma dos pesos seja 1. A introdução das funções de $\log$ tem o objetivo de "suavizar" os valores, uma vez que a quantidade de links diretos ou indiretos entre recursos é exponencialmente maior que o total de links dos dois recursos somados. Com a comparação feita em relação a soma dos links do recurso $r_a$, e $r_b$, garante-se os seguintes axiomas:

\begin{itemize}
	\item{\textbf{Similaridade reflexiva}: $RLWS(r_a, r_a) = RLWS(r_b, r_b), \text{ para todo } r_a \text{ e } r_b$.}
	\item{\textbf{Simetria}: $RLWS(r_a, r_b) = RLWS(r_b, r_a), \text{ para todo } r_a \text{ e } r_b$.}
\end{itemize}

\subsection{Recomendação}

De posse da fórmula de similaridade semântica entre dois recurso, é possível construir o \textit{ranking} de filmes mais similares em relação as preferências do usuário. Para montar o perfil do usuário, este deverá tornar-se uma \textit{query} no mesmo formato de filmes, ou seja, uma lista de termos. Apesar de ser possível utilizar todos os termos de todos os filmes que o usuário gostou, optou-se por escolher uma quantidade determinada de "melhores termos". Esses melhores termos são calculados através de um modelo construído pela frequência, o \ac{TFIDF}. Esse cálculo trata-se de uma estatística que tem por objetivo de refletir o quão importante um termo é para o documento numa coleção \citep{rajaraman_ullman_2011}. 

A primeira parte trata-se da frequência do termo em relação ao documento, o que neste caso refere-se a cada termo de um filme do usuário e sua frequência em relação aos termos desse filme. Quanto a segunda parte refere-se ao inverso da frequência do documento, que busca balancear  os termos muito frequentes em relação aos pouco frequentes, uma vez que não necessariamente todos os termos tem importância igual. Dessa forma é construída uma listagem única de todos os termos de todos os filmes do usuário que para cada um deles seja contabilizado a presença na coleção dos filmes. Dessa forma, é calculado uma avaliação de cada termo, conforme a fórmula {\ref{eq:tfidf}}.

\begin{equation}
	TFIDF(t) = TF(t) * IDF(t)
\label{eq:tfidf}
\end{equation}

\begin{equation}
	TF(t) = \frac{f_{t,d}}{f_{t',d} : t' \in d}
\label{eq:tf}
\end{equation}

\begin{equation}
	IDF(t) = \log (\frac{N}{d \in D : t \in d})
\label{eq:idf}
\end{equation}

Após o cálculo dos melhores termos, é montado o perfil do usuário no mesmo formato de um filme que posteriormente é comparado com todos os outros filmes que o usuário não tenha informado preferência ou tenha desgostado. Dessa forma conclui-se com o algoritmo \ref{alg:alg_recomendacao} para a geração dos filmes recomendados.


\begin{algorithm}
	\caption{Pseudocódigo da geração dos filmes recomendados/sugeridos}
    \begin{algorithmic}[1]
        \Function{GeraRecomendacoes}{$usuario, qtdTermos, qtdSugestoes, filmes$}
        	\State  $outrosFilmes\gets O$\Comment{Diferença entre $filmes$ e o conjunto de filmes de $usuario$ não marcados (like ou deslike)}
        	\State $melhoresTermos\gets$ \Call{ObtemMelhoresTermos}{$usuario, qtdTermos$}
        	\State $similaridades\gets S$\Comment{S é um conjunto vazio de similaridades}
        	\ForAll{filme $f$ de $outrosFilmes$}
        		\State $termosDoFilme\gets f.termos$
        		\State $similaridades$ {inclui} \Call{CalculaRLWSEntreTermos}{$melhoresTermos, termosDoFilme, wi, wd$}
        	\EndFor
        \EndFunction
		
		\State
        \Function{ObtemMelhoresTermos}{$usuario, qtdTermos$}
            \State  $termos\gets U$\Comment{U é o conjunto único de todos os termos dos filmes que o usuário marcou como like}
            \State  $melhoresTermos\gets S$\Comment{S é um conjunto vazio de termos}
            \State  $tfIdfTermos\gets E$\Comment{E é um conjunto vazio do cálculo do TF-IDF do termo}
            \ForAll{termo $t$ de $termos$}
                \ForAll{filme $f$ de $u$}
                    \State $tfIdfTermos$ {inclui o cálculo do TF-IDF do termo $t$ em relação aos termos do filme $f$}
                \EndFor
            \EndFor
            \State {ordena $tfIdfTermos$ de forma decrescente}
            \Return {subconjunto de tamanho $qtdTermos$, da relação de $melhoresTermos$}
        \EndFunction
        
        \State
        \Function{CalculaRLWSEntreTermos}{$termos1, termos2, wi, wd$}\Comment{wd - é o peso para os links diretos, wi - é o peso para os links indiretos}
        	\State $combinacoes\gets 0$
        	\State $similaridade\gets 0$
        	\ForAll{termo $t1$ de $termos1$}
        		\ForAll{termo $t2$ de $termos2$}
        			\State $combinacaoes\gets combinacoes + 1$
        			\State $similaridade\gets$ RLWS($t1, t2, wi, wd$) + $similaridade$
        		\EndFor        	
        	\EndFor
			\If{$combinacoes > 0$}
				\Return $similaridade / combinacoes$
			\Else
				\Return $0$
			\EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:alg_recomendacao}
\end{algorithm}

\section{Sumário}

Neste capítulo foram apresentadas as funcionalidades e especificações do protótipo do projeto, assim como as tecnologias empregadas. Também foram abordadas as etapas do ciclo de vida da aplicação, demonstrando o modelo de dados, assim como a etapa de preparação para recomendação. Por fim foi elaborada a proposta de um novo método de similaridade semântica, mostrando suas características e fórmulas, além dos algoritmos para geração das recomendações. No próximo capítulo serão apresentados os resultados obtidos com novo método elaborado, junto técnicas para sua obtenção, assim como a comparação com outros modelos.